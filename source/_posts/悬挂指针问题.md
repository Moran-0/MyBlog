---
title: c++悬挂指针问题
date: 2025-10-03 17:29:39
categories:
  - 问题记录
tags:
  - C
  - 悬挂指针
---

# 悬挂指针导致预期外的程序行为

## 出现问题原因

> 结构体Temp内成员变量都是char*指针，声明并定义了init函数将Temp&作为参数，在函数内部对Temp结构体内的指针进行了赋值操作，然后调用了init函数后将Temp变量传递给其他模块。由于是在init函数内对char*变量进行赋值，出了该函数作用域后对于的内存被释放，导致Temp结构体内的char*指针指向已释放内存地址，变成悬挂指针。



## 悬挂指针概念

> 悬挂指针是指指向已经被释放（或不再有效）内存的指针。这意味着指针仍然持有旧地址，但该地址所指向的内存已被回收或重新分配。



## **产生原因**

- 对象或内存被删除或释放后，指针依然存在，指向已释放的内存。  
- 例如，使用delete或delete[]操作符释放了堆上分配的内存，但指针没有被置为nullptr。



## **示例**

```c++
#include <iostream>

void danglingPointerExample() {
    int* ptr = new int(10); // 动态分配内存
    delete ptr; // 释放内存

    // ptr 现在是悬挂指针，指向已经释放的内存
    std::cout << *ptr << std::endl; // 未定义行为
}

int main() {
    danglingPointerExample();
    return 0;
}
```

在上述代码中，ptr是一个悬挂指针，因为它指向的内存已经被释放，之后访问它将导致未定义行为（可能是崩溃或错误的值）。



## **如何避免**

- • 将悬挂指针置为nullptr：在释放内存后，可以将指针赋值为nullptr，从而避免悬挂指针问题。

```c++
delete ptr;
ptr = nullptr; // 防止悬挂指针
```

